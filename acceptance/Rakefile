$:.unshift(File.join(File.dirname(__FILE__), "..", "lib"))

require 'fileutils'

require 'ciat'
require 'ciat/compilers/java'
require 'ciat/processors/copy'
require 'ciat/executors/parrot'
require 'ciat/feedback/composite'

desc "Cleans the output directory, compiles the Java code, runs tests"
task :default => [:clean_start, :compile_java,
                  :simple,
                  :java_cat, :java_parrot,
                  :failures, :bad_input,
                  :optional_elements] do
  check_output_files
end

task :compile_java do
  unless system("cd java ; javac *.java")
    raise "Java files failed to compile!"
  end
end

task :clean_start do
  FileUtils.rm_r("temp/") if File.exists?("temp/")
end

task :simple do
  puts "Should copy all the time"
  CIAT::Suite.new(
    :processors => [copy_compiler, copy_executor],
    :files => ['ciat/copy-cat.ciat'],
    :feedback => feedback(1, [:green, :green])).run
end
    
task :java_cat do
  puts "Java compiler, copy executor, TWO tests, special folder"
  CIAT::Suite.new(
    :processors => [java_compiler("Hello"), copy_executor],
    :folder => 'ciat/java-cat',
    :report_filename => 'java-cat.html',
    :feedback => feedback(2, [:green, :green, :green, :green])).run
end

task :java_parrot do
  puts "Java compiler, Parrot executor, special folder"
  CIAT::Suite.new(
    :processors => [java_compiler("Parrot5"), parrot_executor],
    :folder => 'ciat/java-parrot',
    :report_filename => 'java-parrot.html',
    :feedback => feedback(1, [:green, :green])).run  
end

task :failures do
  puts "Should error during compilation"
  CIAT::Suite.new(
    :processors => [java_compiler("Erroring"), DoNotProcessExecutor.new],
    :files => 'ciat/failures/compile-error.ciat',
    :report_filename => 'compile-error.html',
    :feedback => feedback(1, [:yellow, :unset])).run
  puts "Should fail compilation expectation"
  CIAT::Suite.new(
    :processors => [copy_compiler, DoNotProcessExecutor.new],
    :files => 'ciat/failures/compile-fail.ciat',
    :report_filename => 'compile-fail.html',
    :feedback => feedback(1, [:red, :unset])).run
  puts "Should error during execution"
  CIAT::Suite.new(
    :processors => [copy_compiler, ErroringExecutor.new],
    :files => 'ciat/failures/execution-error.ciat',
    :report_filename => 'execution-error.html',
    :feedback => feedback(1, [:green, :yellow])).run
  puts "Should fails execution expectation"
  CIAT::Suite.new(
    :processors => [copy_compiler, copy_executor],
    :files => 'ciat/failures/execution-fail.ciat',
    :report_filename => 'execution-fail.html',
    :feedback => feedback(1, [:green, :red])).run
end

task :bad_input do
  begin
    puts "Should not like missing source element"
    CIAT::Suite.new(
      :processors => [copy_compiler, copy_executor],
      :files => 'ciat/bad-input/missing-source.ciat',
      :report_filename => 'missing-source.html',
      :feedback => blowup_feedback).run
    raise "handled missing source without raising an exception!"
  rescue RuntimeError
  end
  begin
    puts "Should not like missing execution element"
    CIAT::Suite.new(
      :processors => [copy_compiler, copy_executor],
      :files => 'ciat/bad-input/missing-execution.ciat',
      :report_filename => 'missing-execution.html',
      :feedback => blowup_feedback).run
    raise "handled missing execution without raising an exception!"
  rescue RuntimeError
  end
  begin
    puts "Should not like extra element"
    CIAT::Suite.new(
      :processors => [copy_compiler, copy_executor],
      :files => 'ciat/bad-input/extra-element.ciat',
      :report_filename => 'extra-element.html',
      :feedback => blowup_feedback).run
    raise "handled extra element without raising an exception!"
  rescue RuntimeError
  end
end

task :optional_elements do
  puts "Should allow optional 'command line' element with PIR virtual machine"
  CIAT::Suite.new(
    :processors => [copy_compiler, parrot_executor],
    :folder => 'ciat/optional-elements',
    :report_filename => 'optional-elements.html',
    :feedback => feedback(1, [:green, :green])).run
end

#
# Compilers & Executors
#
def copy_compiler
  CIAT::Processors::Copy.new(:source, :compilation, [:source, :compilation])
end

def java_compiler(type)
  CIAT::Compilers::Java.new('./java', type + 'Compiler')
end

def copy_executor
  CIAT::Processors::Copy.new(:compilation_generated, :execution, [:execution])
end

def parrot_executor
  CIAT::Executors::Parrot.new
end

class DoNotProcessExecutor
  def description(element=nil)
    "Should not be executed!"
  end
  
  def process(crate)
    raise("**** should not run this executor!!!")
  end
  
  def required_elements
    [:source, :compilation, :execution]
  end
  
  def optional_elements
    []
  end
  
  def checked_files(crate)
    []
  end
end

class ErroringExecutor
  def description(element=nil)
    "Failing Executor"
  end
  
  def process(crate)
    system("echo this should be the error output > #{crate.filename(:execution, :generated)}")
    false
  end
  
  def required_elements
    [:source, :compilation, :execution]
  end
  
  def optional_elements
    []
  end
  
  def checked_files(crate)
    []
  end
end

#
# Output file checking
#
def check_output_files
  puts "Checking output files."
  Dir["**/*.html"].each do |file|
    system "tidy -mq #{file} 2> /dev/null"
  end
  unless system("diff -r temp_expected/ temp/")
    raise("**** diff failed!")
  end
end

#
# Feedback
#
def feedback(size, expected_lights)
  CIAT::Feedback::Composite.new(
    CIAT::Feedback::StandardOutput.new,
    FeedbackTester.new(size, expected_lights)
    )
end

def blowup_feedback
  BlowupFeedback.new
end

class FeedbackTester
  def initialize(size, expected_lights)
    @size = size
    @expected_lights = expected_lights
    @lights = []
  end
  
  def processor_result(processor)
    @lights << processor.light.setting
  end
  
  def post_tests(suite)
    unless @expected_lights == @lights
      raise "Wrong lights: [#{@expected_lights.join(',')}] expected, got [#{@lights.join(',')}]"
    end
    unless suite.size == @size
      raise "Wrong number of tests: #{@size} expected, got #{suite.size}"
    end
  end
end

class BlowupFeedback
  def processor_result(processor)
    raise "don't call me!"
  end
  
  def post_tests(suite)
    raise "don't call me!"
  end
end
