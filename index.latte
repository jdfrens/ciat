{\head
  {\title CIAT (Compiler and Interpreter Acceptance Tester)}
  }

{\body
  
  {\h1 CIAT (Compiler and Interpreter Acceptance Tester)}
  
  This is a copy of the {\a \href=http://github.com/jdfrens/ciat/blob/master/README.rdoc README.rdoc} from the CIAT gem, despite that same document's promise that this site is a tutorial and reference.
  
  The tutorial and reference are coming!

  {\h2 DESCRIPTION}

  CIAT (pronounced "dog") provides a system for writing high-level acceptance
  tests for compilers and interpreters. Each acceptance test is entered into a
  single file, and that file identifies the elements of a test.

  {\h2 SYNOPSIS}

  Suppose you have a compiler written in Java that compiles a language named
  Hobbes. Your compiler targets the Parrot Virtual Machine. So you want to
  provide {\em source code} which is {\em compiled with a Java program}
  and that result is {\em interpreted by Parrot}.

  {\h3 Input File}

  Input files should be named with a {\code .ciat} extension and saved in a
  {\code ciat} folder.

  A sample input file ({\code simpleinteger5.ciat}) for the scenario
  described above might look like this:

{\pre
Compiles a simple integer.
==== source
5
==== compilation
.sub main
  print 5
  print "\\n"
.end
==== execution
5
}

  This file specifies {\em four} elements: {\strong description}, {\strong
  source}, {\strong compilation}, and {\strong execution}. The description is
  always the first element, always unlabeled, and used prominently in the HTML
  report. All of the other elements are dependent on the processors that you
  use.

  In this example, we're using a "Java compiler" (a compiler {\em written in}
  Java) and a "Parrot executor". CIAT's "Java compiler" runs your compiler
  over the {\strong source}, and that output is compared to the {\strong
  compilation} element. Then the "Parrot executor" is executed with the {\em
  generated} compilation, and that output is compared to the {\strong
  execution} element.

  If any processor fails, either due to an error while running or a failure
  during checking the output, the remaining processors are not executed.

  Some processors will use optional elements in a test file. For example, the
  "Parrot executor" knows about command-line arguments:

{\pre
Compiles a simple integer and ignores the command-line arguments.
==== source
5
==== compilation
.sub main
  print 5
  print "\\n"
.end
==== command line
89 pqp
==== execution
5
}
 
  When the "Parrot executor" is run on the compilation, it'll also pass in
  {\code 89 pqp} as command-line arguments.

  {\h3 The Rakefile}

  This sample {\code Rakefile} pulls everything together:

{\pre
require 'ciat'
require 'ciat/processors/java'
require 'ciat/processors/parrot'

def compiler
  classpath = Dir.glob('../lib/*.jar').join(':') + ":../bin"
  CIAT::Compilers::Java.new(classpath, 'org.norecess.hobbes.drivers.PIRCompiler')
end

def executor
  CIAT::Processors::Parrot.new
end

CIAT::RakeTask.new do |t|
  t.processors << compiler
  t.processors << executor
end
}

  This rakefile will find all of the {\code .ciat} files inside a {\code ciat}
  directory, each one representing a test. Each test will be executed, and the
  results are put into a folder named +temp+, including the HTML report
  {\code report.html}. All of these settings can be tweaked; see the
  documentation for {\code CIAT::RakeTask} for more information.


  {\h2 REQUIREMENTS}

  {\ul
    {\li {\a \href=pronunciation.html Pronounce "CIAT" as "dog".}}
    {\li Must have {\code diff} executable}
    {\li You have to provide your own target-code processors (e.g., 
      {\code parrot} for the Parrot Virtual Machine, {\code spim}
      for MIPS emulation, etc.)}
    }


  {\h2 INSTALL}

  {\ul
    {\li Install {\code diff}.}
    {\li Install Ruby and Ruby Gems.}
    {\li {\code sudo gem install ciat}}
    }

  }
